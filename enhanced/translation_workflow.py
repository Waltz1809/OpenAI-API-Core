#!/usr/bin/env python3
"""
Workflow D·ªãch Thu·∫≠t v√† D·ªçn D·∫πp T·ª± ƒê·ªông
MODULE n√†y ƒë∆∞·ª£c g·ªçi b·ªüi master_workflow.py
"""

import yaml
import time
import openai
import re
import json
import os
import threading
import queue
from datetime import datetime
import sys

# Thay th·∫ø to√†n b·ªô logic import ph·ª©c t·∫°p b·∫±ng m·ªôt d√≤ng import tuy·ªát ƒë·ªëi
from clean_segment import process_yaml as clean_yaml_file, CustomDumper

# --- C√°c h√†m v√† class gi·ªØ nguy√™n ---

def load_yaml(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        return yaml.safe_load(f)

def save_yaml(data, file_path):
    output_dir = os.path.dirname(file_path)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)
    with open(file_path, 'w', encoding='utf-8') as f:
        yaml.dump(data, f, allow_unicode=True, sort_keys=False, Dumper=CustomDumper)

def load_prompt(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        return f.read().strip()

def get_log_filename(output_filename, log_dir):
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)
    base = os.path.splitext(os.path.basename(output_filename))[0]
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    return os.path.join(log_dir, f"{base}_{timestamp}.log")

def write_log(log_file, segment_id, status, error=None):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_message = f"[{timestamp}] {segment_id}: {status}"
    if error:
        log_message += f" - L·ªói: {error}"
    with open(log_file, 'a', encoding='utf-8') as f:
        f.write(log_message + "\n")
    print(log_message)

def title_worker(q, result_dict, client, system_prompt, model, temperature, log_file, lock, delay):
    """H√†m worker cho thread x·ª≠ l√Ω d·ªãch title. T·ªëi ∆∞u cho workflow."""
    while not q.empty():
        try:
            item = q.get(block=False)
            chapter_id, original_title = item
            
            try:
                response = client.chat.completions.create(
                    messages=[
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": f"D·ªãch ti√™u ƒë·ªÅ sau t·ª´ ti·∫øng Trung sang ti·∫øng Vi·ªát, gi·ªØ cho ng·∫Øn g·ªçn v√† ph√π h·ª£p:\n\n{original_title}"}
                    ],
                    model=model,
                    temperature=temperature,
                    max_tokens=200
                )
                
                api_content = response.choices[0].message.content if response.choices and response.choices[0].message else None
                if not api_content:
                    raise ValueError("API kh√¥ng tr·∫£ v·ªÅ n·ªôi dung d·ªãch.")
                
                translated_title = api_content.strip().replace('"', '')
                with lock:
                    result_dict[chapter_id] = translated_title
                    write_log(log_file, f"Title - Chapter: {chapter_id}", "TH√ÄNH C√îNG", f"'{original_title}' -> '{translated_title}'")

            except Exception as e:
                with lock:
                    result_dict[chapter_id] = original_title # Gi·ªØ l·∫°i title g·ªëc n·∫øu l·ªói
                    write_log(log_file, f"Title - Chapter: {chapter_id}", "TH·∫§T B·∫†I", str(e))
            
            q.task_done()
            time.sleep(delay)
        except queue.Empty:
            break

def translate_titles_in_data(segments, client, system_prompt, config, log_file):
    """
    D·ªãch c√°c ti√™u ƒë·ªÅ c√≥ trong d·ªØ li·ªáu segment.
    S·ª≠ d·ª•ng l·∫°i logic t·ªëi ∆∞u: nh√≥m theo ch∆∞∆°ng, d·ªãch 1 l·∫ßn.
    """
    print("\n" + "-"*20 + " B∆Ø·ªöC 1.5: D·ªäCH TI√äU ƒê·ªÄ " + "-"*20)

    # 1. Nh√≥m c√°c segment theo ch∆∞∆°ng v√† l·∫•y ti√™u ƒë·ªÅ duy nh·∫•t
    chapters_to_translate = {}
    chapter_id_pattern = re.compile(r'(Volume_\d+_Chapter_\d+|Chapter_\d+)')

    for segment in segments:
        chapter_id_match = chapter_id_pattern.search(segment.get('id', ''))
        chapter_id = chapter_id_match.group(0) if chapter_id_match else segment.get('id')
        if not chapter_id:
            continue
        original_title = segment.get('title')
        if original_title and original_title.strip() and chapter_id not in chapters_to_translate:
            chapters_to_translate[chapter_id] = original_title

    if not chapters_to_translate:
        print("Kh√¥ng t√¨m th·∫•y ti√™u ƒë·ªÅ m·ªõi c·∫ßn d·ªãch. B·ªè qua.")
        return segments
    
    print(f"üîç T√¨m th·∫•y {len(chapters_to_translate)} ti√™u ƒë·ªÅ ch∆∞∆°ng duy nh·∫•t c·∫ßn d·ªãch.")

    # 2. D·ªãch c√°c ti√™u ƒë·ªÅ b·∫±ng threading
    q = queue.Queue()
    translated_titles_map = {}
    lock = threading.Lock()
    
    for chapter_id, title in chapters_to_translate.items():
        q.put((chapter_id, title))
        translated_titles_map[chapter_id] = None # Kh·ªüi t·∫°o

    api_config = config['translate_api_settings'] # D√πng chung API setting v·ªõi content
    title_config = config['title_translation_settings']
    num_threads = min(api_config.get("concurrent_requests", 5), len(chapters_to_translate))
    threads = []
    
    for _ in range(num_threads):
        t = threading.Thread(
            target=title_worker,
            args=(q, translated_titles_map, client, system_prompt, api_config["model"], 
                  api_config["temperature"], log_file, lock, api_config.get("delay", 1))
        )
        t.daemon = True
        t.start()
        threads.append(t)
    
    for t in threads:
        t.join()

    # 3. C·∫≠p nh·∫≠t l·∫°i d·ªØ li·ªáu YAML g·ªëc v·ªõi c√°c ti√™u ƒë·ªÅ ƒë√£ d·ªãch
    update_count = 0
    for segment in segments:
        chapter_id_match = chapter_id_pattern.search(segment.get('id', ''))
        chapter_id = chapter_id_match.group(0) if chapter_id_match else segment.get('id')

        if chapter_id and chapter_id in translated_titles_map:
            translated_title = translated_titles_map[chapter_id]
            if segment.get('title') != translated_title:
                segment['title'] = translated_title
                update_count += 1
    
    print(f"üîÑ ƒê√£ √°p d·ª•ng b·∫£n d·ªãch ti√™u ƒë·ªÅ cho {update_count} segment.")
    return segments

def worker(q, result_dict, client, system_prompt, model, temperature, max_tokens, log_file, total_segments, lock, delay):
    while not q.empty():
        try:
            idx, segment = q.get(block=False)
            segment_id = segment['id']
            with lock:
                current_processed = len([v for v in result_dict.values() if v is not None])
                print(f"\n[{current_processed + 1}/{total_segments}] ƒêang d·ªãch {segment_id}...")
            try:
                response = client.chat.completions.create(
                    messages=[
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": f"D·ªãch ƒëo·∫°n vƒÉn sau t·ª´ ti·∫øng Trung sang ti·∫øng Vi·ªát:\n\n{segment['content']}"}
                    ],
                    model=model,
                    max_tokens=max_tokens,
                    temperature=temperature
                )
                translated = response.choices[0].message.content
                translated_segment = {'id': segment['id'], 'title': segment['title'], 'content': translated}
                with lock:
                    result_dict[idx] = translated_segment
                    write_log(log_file, segment_id, "TH√ÄNH C√îNG")
            except Exception as e:
                with lock:
                    result_dict[idx] = segment
                    write_log(log_file, segment_id, "TH·∫§T B·∫†I", str(e))
            q.task_done()
            time.sleep(delay)
        except queue.Empty:
            break

def translate_with_threading(segments_to_translate, client, system_prompt, config, log_file):
    q = queue.Queue()
    result_dict = {}
    lock = threading.Lock()
    total_segments = len(segments_to_translate)
    for idx, segment in enumerate(segments_to_translate):
        q.put((idx, segment))
        result_dict[idx] = None
    
    # ·ªû ƒë√¢y, config l√† master_config
    api_config = config['translate_api_settings']
    num_threads = min(api_config.get("concurrent_requests", 5), len(segments_to_translate))
    threads = []
    
    for _ in range(num_threads):
        t = threading.Thread(
            target=worker,
            args=(
                q, result_dict, client, system_prompt, 
                api_config["model"], api_config["temperature"], 
                api_config.get("max_tokens", 4000), log_file, total_segments, lock,
                api_config.get("delay", 1)
            )
        )
        t.daemon = True
        t.start()
        threads.append(t)
    
    for t in threads:
        t.join()
    
    results = []
    failed_count = 0
    for idx in sorted(result_dict.keys()):
        if result_dict[idx] is not None:
            results.append(result_dict[idx])
        else:
            failed_count += 1
            
    if failed_count > 0:
        print(f"‚ö†Ô∏è  C·∫£nh b√°o: C√≥ {failed_count} segment kh√¥ng x·ª≠ l√Ω ƒë∆∞·ª£c (queue empty).")
        
    return results

def translation_workflow(master_config):
    """
    H√†m ch√≠nh ƒëi·ªÅu ph·ªëi quy tr√¨nh d·ªãch v√† d·ªçn d·∫πp.
    Nh·∫≠n to√†n b·ªô c·∫•u h√¨nh t·ª´ master_workflow.
    """
    # =========================================================
    # S·ª¨A L·ªñI ·ªû ƒê√ÇY: D√πng 'translate_api_settings' thay v√¨ 'api_settings'
    # =========================================================
    api_config = master_config['translate_api_settings']
    
    paths = master_config['paths']
    active_task = master_config['active_task']
    cleaner_settings = master_config['cleaner_settings']
    title_settings = master_config.get('title_translation_settings', {})

    input_file = active_task.get('source_yaml_file')
    if not input_file or not os.path.exists(input_file):
        print(f"‚ùå L·ªói: File ngu·ªìn '{input_file}' kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng t·ªìn t·∫°i.")
        return

    output_base = os.path.splitext(os.path.basename(input_file))[0]
    
    # ƒê·ªãnh nghƒ©a ƒë∆∞·ªùng d·∫´n file
    final_output_file = os.path.join(paths['output_dir'], f"{output_base}_cleaned.yaml")
    temp_trans_file = os.path.join(paths['output_dir'], f"{output_base}_temp_trans.yaml")

    system_prompt_file = paths.get('prompt_file')
    if not system_prompt_file or not os.path.exists(system_prompt_file):
        print(f"‚ùå L·ªói: File prompt h·ªá th·ªëng '{system_prompt_file}' kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng t·ªìn t·∫°i.")
        return

    # M·∫∑c ƒë·ªãnh d·ªãch to√†n b·ªô file
    print("\nCh·∫ø ƒë·ªô d·ªãch: D·ªãch to√†n b·ªô file.")
    data = load_yaml(input_file)
    if not data:
        print("Kh√¥ng th·ªÉ ƒë·ªçc file YAML ho·∫∑c file tr·ªëng!")
        return
    segments_to_translate = data

    # ================= B∆Ø·ªöC 1: D·ªäCH THU·∫¨T =================
    print("\n" + "-"*20 + " B∆Ø·ªöC 1: D·ªäCH THU·∫¨T " + "-"*20)
    log_file = get_log_filename(final_output_file, paths['log_dir'])
    client = openai.OpenAI(api_key=api_config["api_key"], base_url=api_config["base_url"])
    system_prompt = load_prompt(system_prompt_file)
    
    with open(log_file, 'w', encoding='utf-8') as f:
        f.write(f"--- B·∫ÆT ƒê·∫¶U WORKFLOW {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ---\n")
        f.write(f"T√°c v·ª•: {active_task.get('task_name', 'Kh√¥ng t√™n')}\n")
        f.write(f"Input: {input_file}\nOutput: {final_output_file}\nModel: {api_config['model']}\n\n")
    
    total_segments = len(segments_to_translate)
    print(f"B·∫Øt ƒë·∫ßu d·ªãch {total_segments} segment v·ªõi {api_config['concurrent_requests']} threads...")
    
    translated_segments = translate_with_threading(
        segments_to_translate, client, system_prompt, master_config, log_file
    )
    
    if not translated_segments:
        print("\n‚ùå D·ªãch thu·∫≠t th·∫•t b·∫°i, kh√¥ng c√≥ segment n√†o ƒë∆∞·ª£c tr·∫£ v·ªÅ. D·ª´ng workflow.")
        return

    # ================= B∆Ø·ªöC 1.5: D·ªäCH TI√äU ƒê·ªÄ (T√ôY CH·ªåN) =================
    if title_settings.get('enabled', False):
        title_prompt_file = title_settings.get('title_prompt_file')
        if not title_prompt_file or not os.path.exists(title_prompt_file):
            print(f"‚ö†Ô∏è  C·∫£nh b√°o: Kh√¥ng t√¨m th·∫•y file prompt cho ti√™u ƒë·ªÅ t·∫°i '{title_prompt_file}'. B·ªè qua d·ªãch ti√™u ƒë·ªÅ.")
        else:
            title_system_prompt = load_prompt(title_prompt_file)
            translated_segments = translate_titles_in_data(
                translated_segments, client, title_system_prompt, master_config, log_file
            )

    save_yaml(translated_segments, temp_trans_file)
    print(f"\n‚úÖ B∆∞·ªõc 1 ho√†n th√†nh! K·∫øt qu·∫£ d·ªãch th√¥ l∆∞u t·∫°i: {temp_trans_file}")

    # ================= B∆Ø·ªöC 2: D·ªåN D·∫∏P K·∫æT QU·∫¢ =================
    if cleaner_settings.get('enabled', False):
        print("\n" + "-"*20 + " B∆Ø·ªöC 2: D·ªåN D·∫∏P K·∫æT QU·∫¢ " + "-"*20)
        try:
            print(f"ƒêang d·ªçn d·∫πp file: {temp_trans_file}")
            clean_yaml_file(temp_trans_file, final_output_file)
            print(f"‚úÖ B∆∞·ªõc 2 ho√†n th√†nh! K·∫øt qu·∫£ ƒë√£ d·ªçn d·∫πp l∆∞u t·∫°i: {final_output_file}")
        except Exception as e:
            print(f"‚ùå L·ªói trong qu√° tr√¨nh d·ªçn d·∫πp: {e}")
            print(f"Gi·ªØ l·∫°i file d·ªãch th√¥ t·∫°i: {temp_trans_file}")
            return
        finally:
            if os.path.exists(temp_trans_file):
                os.remove(temp_trans_file)
                print(f"ƒê√£ x√≥a file t·∫°m: {temp_trans_file}")
    else:
        print("\n" + "-"*20 + " B∆Ø·ªöC 2: D·ªåN D·∫∏P K·∫æT QU·∫¢ (B·ªé QUA) " + "-"*20)
        os.rename(temp_trans_file, final_output_file)
        print(f"‚úÖ K·∫øt qu·∫£ cu·ªëi c√πng l∆∞u t·∫°i: {final_output_file}")

    with open(log_file, 'a', encoding='utf-8') as f:
        f.write(f"\n--- K·∫æT TH√öC WORKFLOW {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ---\n")
        f.write(f"T·ªïng s·ªë segment ƒë√£ x·ª≠ l√Ω: {total_segments}\n")
    
    print("\nüéâ D·ªäCH THU·∫¨T HO√ÄN T·∫§T! üéâ")
    print(f"K·∫øt qu·∫£ cu·ªëi c√πng: {final_output_file}")
    print(f"Log chi ti·∫øt: {log_file}")

if __name__ == "__main__":
    # Logic g·ªçi workflow ch√≠nh s·∫Ω ƒë∆∞·ª£c th√™m ·ªü ƒë√¢y
    print("Kh·ªüi t·∫°o workflow...")